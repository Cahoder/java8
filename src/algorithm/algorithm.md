###数据结构
![数据结构](http://upload.ouliu.net/i/20200809102321un2p6.jpeg "数据结构")
###算法分类
![算法分类](http://upload.ouliu.net/i/20200809102556r5bg0.jpeg "算法分类")
###如何评价一个算法的好坏？
1. 正确性、可读性、健壮性
2. 时间复杂度:估算程序指令的执行次数（执行时间）
3. 空间复杂度:估算所需占用的存储时间

###时间复杂度的估算？--- 假设每条指令执行时间相同
```
    //无论有多少个分支判断，最终都只会执行1条 ≈ 1(次)
	if(n==1) System.out.println("hello");
	else if(n==2) System.out.println("hello");
	else System.out.println("hello");

	// (int i = 0)1次 + (i<n)n次 + (i++)n次 + (输出hello)n次 ≈ 1 + 3n (次)
	for(int i = 0; i < n; i++) 
		System.out.println("hello");

	// (int i = 0)1次 + (i<n)n次 + (i++)n次
	for(int i = 0; i < n; i++) 
		// (外层for)n次 * [(int j = 0)1次 + (j<n)n次 + (j++)n次 + (输出hello)n次] 
		for(int j = 0; j < n; j++)
			System.out.println("hello"); //合计 ≈ 1 + 2n + n*(1+3n) <==> 3n^2 + 3n + 1

	// i+=i && i<n <==> i=i*2 && i<n <==> i<<1 && i<n ≈ log2(n) (次)
	// (int i = 1)1次 + (i<n)log2(n)次 + (i+=i)log2(n)次log2(n)次
	for(int i = 1; i < n; i+=i) 
		// (外层for)log2(n)次 * [(int j = 0)1次 + (j<n)n次 + (j++)n次 + (输出hello)n次] 
		for(int j = 0; j < n; j++)
			System.out.println("hello"); //合计 ≈ 1+log2(n)+log2(n) + log2(n)*(1+3n) <==> 3nlog2(n) + 3log2(n) + 1

	/* 遇到while条件只考虑里面能执行多少次 */
	// (n = n/2) > 0 ==> 2^x次 = n ≈ log2(n) (次)
	while((n = n/2) > 0) 
		System.out.println("hello");

	// (n = n/5) > 0 ==> 5^x次 = n ≈ log5(n) (次)
	while((n = n/5) > 0) 
		System.out.println("hello");
```

###大O表示法？--- 忽略常数、系数、低阶、对数的底数，短时间内粗略的算法分析模型
```
	9 ==> O(1)
	2n + 3 ==> O(n)
	n^2 + 2n + 6 ==> O(n^2)
	4n^3 + 3n^2 + 22n + 100 ==> O(n^3)
	log2(n) = log2(9) * log9(n) ==> O(logn)
	nlog2(n) + log2(n) + 1 ==> O(nlogn + logn) ==> O(nlogn)

	注：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
```

###空间复杂度的估算？--- 假设每个变量占用的存储空间大小相同
```
	// (int a)1 + (int b)1 + (int c)1 + (int[] arr)n + (int i)1 ≈ n + 4
	int a = 10;
	int b = 10;
	int c = a+b;
	int[] arr = new int[n];
	for(int i = 0; i < arr.length; i++) 
		System.out.println("hello");
```

###算法的优化方向？
1. 用尽量少的存储空间
2. 用尽量少的执行步骤（执行时间）
3. 根据实际情况：空间换时间 or 时间换空间

###多个数据规模情况？
```
	for(int i = 0; i < n; i++) 
		System.out.println("hello");
	for(int j = 0; j < k; j++)
			System.out.println("world");
	//空间复杂度O(1),时间复杂度O(n+k);
```

###最好复杂度？
* O(1)
###最坏复杂度？
* O(n)
###平均复杂度？
* [O(1)+O(2)+...+O(n)]/n
###均摊复杂度？
* 经过连续的多次复杂度比较低的情况后,出现个别复杂度比较高的情况
###复杂度震荡？
* 扩容倍数 * 缩容倍数 ！= 1 , 即可解决

---------------------------------------------------
###树的基本概念
* '节点' '根节点' '父节点' '子节点' '兄弟节点' '子树' '左子树' '右子树'
* 无任何节点的树称为'空树'
* 节点的度(degree) : 子树的个数
* 树的度 : 所有节点度中的最大值
* 叶子节点(leaf) : 度为0的节点
* 非叶子节点 : 度不为0的节点
* 层数(level) : 根节点在第 1 层,根节点的子节点在第 2 层,以此类推(有些教程也从第 0 层开始计算)
* 节点的深度(depth) : 从根节点到当前节点的唯一路径上的节点总数
* 节点的高度(height) : 从当前节点到最远叶子节点的路径上的节点总数
* 树的深度 : 所有节点深度中的最大值
* 树的高度 : 所有节点高度中的最大值
* 树的深度 等于 树的高度
* 有序树 : 树中任意节点的子节点之间有顺序关系,顺序不同不视为同一颗树
* 无序树 : 树中任意节点的子节点之间有顺序关系,也称为“自由树”
* 森林 : 由 m(m ≥ 0) 棵互不相交的树组成的集合
####二叉树(Binary Tree)的性质
* 前驱节点(predecessor) : 中序遍历时的前一个节点
* 后继节点(successor) : 中序遍历时的后一个节点
* 每个节点的度最大为2
* 二叉树属于**有序树**
* 非空二叉树第i层最多有 (2^i-1) 个节点(i ≥ 1)
* 高度为h的二叉树上最多有 (2^h) - 1 个节点(i ≥ 1)
* 假设二叉树中叶子节点个数为 n0,度为 1 的节点个数为 n1,度为 2 的节点个数为 n2,则有: **n0 = n2 + 1**
```
 证明: n0 = n2 + 1
    1.二叉树的总节点数 n = n0 + n1 + n2
    2.除了根节点之外每个节点上面都有一条边
    3.二叉树的边数 T = n1 + 2 * n2 = n – 1 = (n0 + n1 + n2) – 1
 综上所得: n0 = n2 + 1
```
####二叉树(Binary Tree)的遍历
#####前序遍历(Preorder Traversal)
* 递归
* 非递归
+ 应用 : 树状打印
 #####中序遍历(Inorder Traversal)
* 递归
* 非递归
#####后序遍历(Postorder Traversal)
* 递归
* 非递归
#####层序遍历(Level Order Traversal)
* 非递归
+ 应用 : 1. 计算二叉树高度 2. 判断是否为完全二叉树
```
#####前序遍历+中序遍历 <---> 重构二叉树
#####后序遍历+中序遍历 <---> 重构二叉树
#####前序遍历+后序遍历+真二叉树前提条件 <---> 重构二叉树
```
####扩充二叉树(Extended Binary Tree)
* 二叉树中出现空子树的位置增加空树叶
####真(完满)二叉树(Proper/Full Binary Tree)
* 二叉树中不存在度为 1 的节点
####满(完美)二叉树(Full/Perfect Binary Tree)
* 二叉树中不存在度为 1 的节点
* 叶子节点都在二叉树的最后一层
* 同等高度的二叉树中,满二叉树的叶子节点和总节点数都最多
* 满二叉树一定是真二叉树,真二叉树不一定是满二叉树

* 满二叉树第i层有 (2^i-1) 个节点
* 高度为h的满二叉树有 (2^h-1) 个叶子节点,总共有(2^h) - 1 个节点
* n个节点的满二叉树的高度 h = log2(n+1)
####完全二叉树(Complete Binary Tree)
* 叶子节点只会出现最后 2 层,最后 1 层的叶子结点都靠左对齐
* 完全二叉树从根节点到倒数第2层是一颗满二叉树
* 满二叉树一定是完全二叉树,完全二叉树不一定是满二叉树

* 完全二叉树度为1的节点最多只有一个,且只能是左子树(靠左对齐)
* 同等节点数量的二叉树,完全二叉树的高度最小
* 假设完全二叉树的高度为h (h≥1),那么至少有 2^(h-1) 个节点,至多有 (2^h)-1 个节点
* 一棵有 n 个节点的完全二叉树(n > 0),其叶子节点 n0 = floor( (n+1)/2 ) = ceiling( n/2 ) = (n+1) >> 1
```
    那么对于总节点数 n 则有如下推论:
    2^(h-1) ≤ n < 2^h
    h-1 ≤ log2n < h
    综上所得: h = floor(log2n) + 1 = ceiling(log2n)
```

* 一棵有 n 个节点的完全二叉树(n > 0),从上到下&&从左到右对节点从 1 开始进行编号,对任意第 i 个节点有如下定理:
```
    如果i = 1,它是根节点
    如果i > 1,其父节点编号为floor(i/2)
    如果2i ≤ n ,它的左子节点编号为 2i
    如果2i > n ,它无左子节点
    如果2i+1 ≤ n ,它的右子节点编号为 2i+1
    如果2i+1 > n ,它无右子节点
```
* 一棵有 n 个节点的完全二叉树(n > 0),从上到下&&从左到右对节点从 0 开始进行编号,对任意第 i 个节点有如下定理:
```
    如果i = 0,它是根节点
    如果i > 0,其父节点编号为floor((i-1)/2)
    如果2i+1 ≤ n-1 ,它的左子节点编号为 2i+1
    如果2i+1 > n-1 ,它无左子节点
    如果2i+2 ≤ n-1 ,它的右子节点编号为 2i+2
    如果2i+2 > n-1 ,它无右子节点
```
####二叉搜索树(Binary Search Tree)
* 任意一个节点的值都大于其左子树所有节点的值
* 任意一个节点的值都小于其右子树所有节点的值
* 二叉搜索树的左右子树也是一棵二叉搜索树
* 二叉搜索树存储元素必须具备可比较性,因此元素不允许为null
* 二叉搜索树的中序遍历是一个升序数组
####平衡二叉搜索树(Balanced Binary Search Tree)
* 防止二叉搜索树由于添加删除操作退化成链表,保证添加删除为O(logn)
* 左右子树高度差越小,说明它越平衡
* 用尽量少的调整次数达到适度平衡即可,追求理想平衡可能会适得其反

---
####自平衡二叉搜索树
#####AVL树
* 平衡因子(Balance Factor) : 某节点的左右子树高度差(H左 - H右)
* AVL树特点
  + 每个节点的平衡因子只能是 0 -1 1 <===> |Balance Factor| ≤ 1
  + 每个节点的左右子树高度差不超过1,否则称之为"失衡"
  + 搜索为O(logn)
  + 添加为O(logn),仅需O(1)次旋转调整
  + 删除为O(logn),最坏需要O(logn)次旋转调整
> AVL树由于添加导致的失衡
* 可能导致所有的祖先节点都失衡,只要让高度最低的失衡节点恢复平衡即可,常数(1-2)次旋转
* LL - 右旋转(单旋) - 左孙子(x.Left.Left)添加操作必定导致祖父(x)节点失衡
  + grandparent.left = parent.right
  + parent.right = grandparent
  + parent旋转后成为新的grandparent
* RR - 左旋转(单旋) - 右孙子(x.Right.Right)添加操作必定导致祖父(x)节点失衡
  + grandparent.right = parent.left
  + parent.left = grandparent
  + parent旋转后成为新的grandparent
* LR - 先RR后LL(双旋) - 左儿右孙(x.Left.Right)添加操作必定导致祖父(x)节点失衡
  ![LR操作](http://upload.ouliu.net/i/20200817121445rtul4.png "LR操作")
  1. **先左旋parent**
  + parent.right = parent.right.不是添加操作子树
  + parent.right.left = parent
  + parent.right旋转后成为新的parent <==> grandparent.left = parent.right
  2. **后右旋grandparent**
  + grandparent.left = parent.right.添加操作子树
  + parent.right.right = grandparent
  + parent.right旋转后成为新的grandparent
* RL - 先LL后RR(双旋) - 右儿左孙(x.Right.Left)添加操作必定导致祖父(x)节点失衡
  ![RL操作](http://upload.ouliu.net/i/202008171215289rfst.png "RL操作")
  1. **先右旋parent**
  + parent.left = parent.left.不是添加操作子树
  + parent.left.right = parent
  + parent.left旋转后成为新的parent <==> grandparent.right = parent.left
  2. **后左旋grandparent**
  + grandparent.right = parent.left.添加操作子树
  + parent.left.left = grandparent
  + parent.left旋转后成为新的grandparent
> AVL树由于删除导致的失衡
* 删除节点仅导致父节点或祖先节点(其中1个节点)失衡,其他节点都不可能失衡
* 但旋转调整后可能导致更高层的祖先节点失衡,最坏需要O(logn)次

#####红黑树
* 也称作 二叉平衡B树(Symmetric Binary B-tree)
* 红黑树必须满足的5条性质
  1. 每个节点只能是 **RED** or **BLACK**
  2. 根节点是 **BLACK**
  3. 出现空子树的位置都是**BLACK**空树叶(类似扩充二叉树)
  4. **RED**节点的子节点都是**BLACK**
    + **RED**节点的父节点都是**BLACK**
    + 从根节点到其任意叶子节点(空子树的位置)不能有2个连续的**RED**节点
  5. 从任意节点到其任意叶子节点(空子树的位置)都包含相同数量的**BLACK**节点(是否算上空子树都可)
* 红黑树与B树的关系
  + 红黑树与4阶B树(2-3-4树)具有等价性
  + **BLACK**与其**RED**子节点融合,就能形成一颗4阶B树
  + **BLACK**节点个数 == 融合后4阶B树的节点总数
  + 红黑数的平衡指的是转换成B树的平衡
* 红黑树特点
  + 红黑树的平衡标准相对宽松 : 没有一条路径会大于其他路径的2倍 (最长路径和最短路径之间倍数 ≤ 2)
  + 弱平衡,但忽略红节点的黑节点高度平衡
  + 红黑树的最大高度是 2*log2(n+1)  ≈  O(logn)级
  + 搜索为O(logn)
  + 添加为O(logn),仅需O(1)次旋转调整
  + 删除为O(logn),最坏需要O(1)次旋转调整 --- 牺牲部分平衡以换取插入/删除时更少量旋转
> 红黑树添加情况的分析
  * 首先红黑树的添加肯定发生在叶子节点 --- B树特点
  * 默认新添加的节点为**RED**节点,但如果新节点是根则需染黑
  * 那么原叶子节点的长相只有四种可能,可添加的位置有12个
    `例如下图  ->   红黑红:(ACEG)   黑红:(ACE)   红黑:(ACE)   黑:(AC)`
  ![红黑树与4阶B树](https://ftp.bmp.ovh/imgs/2020/08/d0424226c071b338.png  "最底层的黑色节点就是添加位置")
    + 有4个位置是绝对满足红黑树和B树的性质,添加后不用做额外处理 --- **parent**是**BLACK**的时候
    + 有8个位置是不满足红黑树和B树的性质,添加后需要做额外处理 --- **parent**是**RED**的时候
        + 在黑红(RR)和红黑(LL)叶子节点的红色节点下添加 --- (**uncle**不是**RED**)
            1. RR - 原parent染成黑色,原grandparent染成红色,对原grandparent进行左旋
            2. LL - 原parent染成黑色,原grandparent染成红色,对原grandparent进行右旋
        + 在黑红(RL)和红黑(LR)叶子节点的红色节点下添加 --- (**uncle**不是**RED**)
            3. RL - 新节点染成黑色,原grandparent染成红色,先对原parent右旋后对原grandparent左旋
            4. LR - 新节点染成黑色,原grandparent染成红色,先对原parent左旋后对原grandparent右旋

        + 在红黑红(RR)和红黑红(LL)叶子节点的红色节点下添加,此时肯定发生上溢 --- (**uncle**是**RED**)
            5. RR - 原parent和uncle染成黑色,将原grandparent染成红色然后向上合并(当作新添加节点递归处理)
            6. LL - 原parent和uncle染成黑色,将原grandparent染成红色然后向上合并(当作新添加节点递归处理)
        + 在红黑红(RL)和红黑红(LR)叶子节点的红色节点下添加,此时肯定发生上溢 --- (**uncle**是**RED**)
            7. RL - 原parent和uncle染成黑色,将原grandparent染成红色然后向上合并(当作新添加节点递归处理)
            8. LR - 原parent和uncle染成黑色,将原grandparent染成红色然后向上合并(当作新添加节点递归处理)
> 红黑树删除情况的分析
  * 首先红黑树的删除肯定发生在叶子节点 --- B树特点
  * 那么节点长相只有两种可能(RED|BLACK)
  ![红黑树的删除](https://ftp.bmp.ovh/imgs/2020/08/b24edb0c921756d2.png "最底层的叶子就是删除的位置")
    + 如果删除的节点是**RED**,删除后不用做额外处理
    + 如果删除的节点是**BLACK**,删除后分情况做额外处理
        1. 如果删除的**BLACK**节点拥有2个**RED**子节点,无需操作 --- 因为被删除的肯定是它的(前驱|后继),而它的(前驱|后继)都是**RED**
        2. 如果删除的**BLACK**节点拥有1个**RED**子节点 --- 因为肯定要拿**RED**子节点替代它位置
            + 将替代它的**RED**子节点的颜色染成黑色,保证红黑树性质
        3. 如果删除的**BLACK**节点没有子节点 --- 没有子节点可以看作是拥有2个NULL的黑色子节点,需要分情况考虑
            + 站在B树的角度看,直接删掉会产生下溢,除了看兄弟节点有没有资格借,还要看兄弟节点是否有足够的节点借
                + 如果兄弟节点为**BLACK**,有资格借出,并且至少有一个**RED**子节点
                    ![红黑数叶子节点删除_情况1](https://ftp.bmp.ovh/imgs/2020/08/1cea852ec20a8a05.png)
                    * 对兄弟节点进行旋转操作 --- (这里旋转时,如果兄弟节点有两个**RED**子节点,旋转规则不同结果也不同)
                    * 将旋转后新的**parent**节点染成旧的**parent**节点颜色
                    * 将新的**parent**节点的左右子节点(需要独立)染成黑色
                + 如果兄弟节点为**BLACK**,有资格借出,但是没有**RED**子节点
                    ![红黑数叶子节点删除_情况2](https://ftp.bmp.ovh/imgs/2020/08/93fe82fe9c32781e.png)
                    * 如果**parent**节点是红色,先将兄弟节点染成RED,父节点染成BLACK,然后将**parent**节点拿下来和兄弟节点合并
                    ,并且绝对不会导致**parent**节点继续下溢的,因为原**parent**红色节点肯定是被融合的
                    * 如果**parent**节点是黑色,先将兄弟节点染成RED,父节点染成BLACK,然后将**parent**节点拿下来和兄弟节点合并
                    ,绝对会导致**parent**节点继续下溢,需要将**parent**节点当做被删除节点递归调用
                + 如果兄弟节点为**RED**,没有资格借出,因为它在B树的角度看不能成为独立的节点
                    ![红黑数叶子节点删除_情况3](https://ftp.bmp.ovh/imgs/2020/08/7fca2f730a0fe27b.png)
                    * 此时需要看兄弟节点的子节点,让兄弟节点的子节点成为变成自己新的兄弟,因为**RED**节点的子节点肯定是**BLACK**的,
                    就可以按照上面兄弟节点为**BLACK**的情况一样考虑
                    * 先将原兄弟节点染成BLACK,原父节点染成RED,然后对原**RED**兄弟节点进行旋转操作
                    * 旋转后原兄弟节点的子节点就成为自己新的兄弟,再按照上面兄弟节点为**BLACK**的情况一样考虑

#####AVL树 VS 红黑树
* AVL树
    + 平衡标准比较严格: 每个左右子树的高度差不超过1
    + 最大高度 1.44 * log2(n+2) - 1.328 (100W节点,AVL最大树高28)
    + 搜索添加删除都是O(logn)复杂度,其中添加最多需要O(1)次旋转调整,删除最多需要O(logn)次旋转调整
* 红黑树
    + 平衡标准比较宽松: 没有一条路径会大于其他路径的2倍
    + 最大高度 2 * log2(n+1) (100W节点,AVL最大树高40)
    + 搜索添加删除都是O(logn)复杂度,其中添加最多需要O(1)次旋转调整,删除最多需要O(1)次旋转调整
* 结论
    + 如果搜索次数远远大于添加删除,选择AVL树;
    + 如果搜索添加删除次数差不多,整体选择红黑树;
    + 红黑树牺牲部分平衡以换取插入/删除时更少量旋转;
    
####平衡多叉搜索树(Balanced X Search Tree)
#####B树(B-tree B-树)
* B树是一种平衡的多路搜索树,多用于文件系统和数据库的实现 (例如: Mysql是200-300阶的B+树)
* B树的特点
  + 1个节点可以存储超过2个元素,可以拥有超过2个子节点,因此树高度较小
  + 通过Max(子节点数),称之为m阶B树
  + 拥有二叉搜索树的一些性质
  + 十分平衡,每个节点的所有子树高度一致
* m阶B树的性质 (m ≥ 2),当**m=2**时就是二叉搜索树
  + 假设一个节点存储的元素个数为 x
    + 根节点的元素个数 = [ 1, m-1 ]
    + 非根节点的元素个数 = [ ceiling(m/2)-1 , m-1 ]
  + 假设一个节点有子节点,其子节点个数 y = x + 1
    + 根节点的子节点个数 = [ 2, m ]
    + 非根节点的子节点个数 = [ ceiling(m/2) , m ]
* B树 和 二叉搜索树 之间的关联
  + 首先它们在逻辑上是等价的
  + 二叉搜索树的多代节点合并,可以成为B树的一个超级节点 (即节点中放多代节点)
    + 二叉搜索树(父子)代合并的超级节点(≤3),最多可拥有4个子节点 (至少4阶B树)
    + 二叉搜索树(爷父子)代合并的超级节点(≤7),最多可拥有8个子节点 (至少8阶B树)
    + ...
    + 二叉搜索树(n)代合并的超级节点(≤2^n-1),最多可拥有2^n个子节点 (至少2^n阶B树)
  + 因此反过来,m阶B树,最多需要二叉搜索树的log2m代合并
* B树的搜索
  + 跟二叉搜索树的搜索类似
* B树的添加
  + 新加入的元素必然在叶子节点中
  + 如果原本叶子节点元素个数为 m-1 个,再插入会产生上溢(overflow)现象
  + 上溢(overflow)现象的解决:
    + 此时上溢节点的元素个数必然为 m 个
    ```
        while(父节点!=null){
            //将上溢节点的中间元素k取出
            k = ceiling(m/2)-1;
            //将中间元素k与其父节点合并
            父节点.merge(k)
            //将[0,k-1]和[k+1,m-1]位置的元素分裂成2个子节点
            //2个子节点的元素个数就必然不会低于ceiling(m/2)-1
            k.son1 = [0,k-1];
            k.son2 = [k+1,m-1];
            //判断父节点是否由于合并发生了上溢
            if(父节点未上溢) break;
            else continue;
        }
        //如果一直向上合并,导致根节点也上溢
        if(父节点==null) {
            //将上溢节点的中间元素k取出
            k = ceiling(m/2)-1;
            //让k成为新的根节点,B树高度+1
            root = k;
            //将[0,k-1]和[k+1,m-1]位置的元素分裂成2个子节点
            k.son1 = [0,k-1];
            k.son2 = [k+1,m-1];
        }
    ```
* B树的删除
  + 假如删除的元素在非叶子节点中
    1. 那么需要中序找到其前驱或后继(叶子)节点
    2. 判断其前驱或后继节点中元素个数是否 ≥ ceiling(m/2)
       + 如果前驱或后继节点中元素个数足够,找前驱的最大或者后继的最小元素替代它,然后删除替代的元素
       + 如果前驱或后继节点中元素个数不足以替代,据需要进行节点的合并,并进行上溢判断
  + 因此真正发生删除操作都是在叶子节点中
  + 假如删除的元素在叶子节点中
      1. 如果 ceiling(m/2) ≤ 叶子节点元素个数 ≤ m-1 , 则可以直接删除
      2. 如果原本叶子节点元素个数为 ceiling(m/2)-1 个,再删除会产生下溢(underflow)现象
  + 下溢(underflow)现象的解决:
    + 此时下溢节点的元素个数必然为 ceiling(m/2)-2 个
    ```
        if(有兄弟节点 && (ceiling(m/2) ≤ 某个兄弟节点元素个数 ≤ m-1)){
            //去父节点中取元素b,b必须大于兄弟节点并且小于当前节点
            b = 父节点中的元素;
            //去兄弟节点中取元素a,a是兄弟节点中的最大位置
            a = 兄弟节点中的元素;
            //将父节点中的b加入到当前节点中的最小位置
            (ceiling(m/2)-2).merge(b);
            //将兄弟节点中的a替代父节点原来b的位置
            b = a;
            //修改子树情况
            b.左子树 = a.右子树;
        }
        else if(无兄弟节点 || (ceiling(m/2)-1 == 每个兄弟节点元素个数)){
            while(父节点!=null){
                //去父节点中取出元素b,b必须大于兄弟节点并且小于当前节点
                b = 父节点中的元素;
                //将元素b和被删除节点和(ceiling(m/2)-1)的兄弟节点合并,成为被删除节点
                //放心 (ceiling(m/2)-2) + (ceiling(m/2)-1) + 1 绝对不超过 m-1
                (ceiling(m/2)-2).merge(b).merge(兄弟节点);
                //判断父节点是否由于减少元素发生了下溢
                if(父节点未下溢) break;
                else continue;
            }
            //如果一直向上取元素,导致根节点也下溢
            if(父节点==null) {
                //将根节点和其子节点合并成为新的根
                root = root.merge(其子节点);
            }
        }
    ```

---------------------------------------------------
###集合与映射的基本概念
#### Set集合的特点
* 不存放重复的元素
* 常用于去重
#### Map映射的特点
* 其他编程语言中也叫做字典(dictionary,比如 Python、Objective-C、Swift 等)
* 存在**Key**与**Value**的映射关系
* Map中的每个**Key**是唯一的
* Map中的每个**Value**允许重复
* 缺点1: **Key必须具备可比较性**,自定义对象必须实现比较器功能
* 缺点2: **元素的分布是有顺序的**,实际开发中存在不考虑顺序情况
#### Map 与 Set
* 可以使用链表或数组实现,复杂度O(n)
* 也可以使用二叉搜索树(AVL树或红黑树)实现,复杂度O(logn)
* Map 的所有 key 组合在一起,其实就是一个 Set
* JDK官方TreeMap实现就是红黑树,TreeSet使用TreeMap的Key

---------------------------------------------------
###哈希表的基本概念
#### 哈希表映射的特点
* 典型的使用空间换时间
* 存储的元素不需要讲究顺序
* 映射中的**Key**不需要具备可比较性
* 不考虑顺序和比较性的前提,映射平均复杂度可以达到O(1)
#### 哈希表添加|搜索|删除的实现
![哈希表](https://ftp.bmp.ovh/imgs/2020/09/34f386189741ec9b.png "使用数组维护索引")
1. 利用哈希函数(散列函数)生成key对应的index  ---  O(1)
2. 根据table[index]定位数组元素  ---  O(1)
* 哈希表内部的数组元素叫Bucket(桶),整个数组叫Buckets或者Bucket Array
#### 哈希冲突(哈希碰撞)
![哈希冲突](https://ftp.bmp.ovh/imgs/2020/09/900ccc304f40f943.png "hash(key1) = hash(key2)")
* 2个或以上不同的key,经过哈希函数计算出来的index相同
* 常用的解决哈希冲突方法
  1. 开放定址法(Open Addressing)  ---  按照一定规则向其他地址探测(线性探测|平方探测),直到遇到空桶
  2. 再哈希法(Re-Hashing)  ---  设计多个哈希函数
  3. 拉链法(链地址法Separate Chaining)  ---  通过链表将hash(key)计算为相同index的元素串起来
* JDK1.8默认使用哈希表+单向链表|红黑树的方案解决哈希冲突
  + 默认使用单向链表将元素串起来
  + 添加元素时,可能会由单向链表转为红黑树来存储元素
    + 例如当哈希表容量≥64且单向链表的节点数量>8时
  + 当红黑树节点数量少到一定程度时,又会转为单向链表
  + 思考: 为什么使用单链表而不使用双链表?
    + 首先针对计算出相同index的不同key,需要先判断此key是否已经存在链表中
    + 因此我们每次都需要从链表的头节点向尾节点方向遍历判断key是否已存在
    + 而且双向链表需要维护多一个指针,这会耗费无必要的内存空间
* 哈希表中生成index的哈希函数如何实现?
  1. 根据给定的key生成哈希值(必须是整数)
  2. 再让key的哈希值跟数组的大小进行相关运算,生成index
  ```
    public int hash(Object key){
        //table.length取2的幂次方 ===> 相应的2进制为 1000....
        // 1000.... - 1 ===> 0111...111
        // & 运算后值的2进制的范围在 0 ~ table.length - 1
        // 刚好就获得了table的所有index
        return hashCode(key) & (table.length - 1);
    }
  ```
* hashCode(key)哈希值生成
  + 良好的hashCode(key)应该分布均匀,减少哈希冲突,能够提升哈希表性能
  1. 整数 - 将整数值当做哈希值
  2. Float - 将浮点数在内存中按IEEE规范的二进制直接转成十进制整数
      ```
          public int hashCode(long key){
              //1000001001010011001100110011010 --> 1093245338
              Float.floatToIntBits(10.6F);
          }
      ```
  3. Long和Double - 将全部64位的long或double进行相关操作然后变成32位
      ```
          public int hashCode(long key){
              //首先将64位long无符号右移32位 (为了获取高32位)
              //再与原来64位long进行异或操作 (高32位与低32位异或)
              return (int)(key ^ (key >>> 32));
          }
          public int hashCode(double key){
              //先将double转成long再按照long的做法
              long val = Double.doubleToLongBits(key);
              return (int)(val ^ (val >>> 32));
          }
      ```
  4. 字符串 - 将字符串拆分成一个个字符,获取每个字符ASCII按权展开求和
      ```
         //例如字符串jack ==> j*n^3 + a*n^2 + c*n^1 + k*n^0 === [(j*n + a)*n + c]*n + k
         //JDK中,乘数n取31,为什么使用31?
         //31是一个奇素数,JVM会将 31*i 优化成 (i<<5)-i
         // 31*i = (2^5 - 1) * i = (2^5 * i) - i = (i<<5) -i
         // 31 即是一个奇数又是一个素数 --- 素数与其他数相乘更容易产生唯一性,减少哈希冲突
         public int hashCode(String key){
              int hashCode = 0;
              for (int i = 0; i < key.length(); i++) {
                  char c = key.charAt(i);
                  //JVM会优化成 hashCode = (hashCode<<5)-hashCode + c;
                  hashCode = hashCode * 31 + c;
              }
              return hashCode;
         }
      ```
  5. 自定义对象 - 默认跟对象的内存地址有关
      * 如果不想存储到哈希表时被当成两个不同的index索引,需要重写对象的hashCode方法
        ```
            //保证equals()为true的2个key的哈希值相同
            @Override
            public int hashCode(){
                int hashCode = Integer.hashCode(age);
                int hashCode = hashCode * 31 + Float.hashCode(height);
                return hashCode;
            }
        ```
      * 由于JDK1.8默认使用哈希表+单向链表|红黑树的方案解决哈希冲突
      ,因此为了防止链表|红黑树判断key是否相等,还需要重写对象的equals方法,并且允许key为null
        ```
            //判断hashCode相同的2个key是否相同
            @Override
            public boolean equals(Object obj){
                //如果内存地址相同
                if(this == obj) return true;
                //如果传入的对象为null,或者两个对象不是同一个类
                if(obj == null || obj.getClass() != this.getClass()) return false;
                //如果两个对象属于同一个类
                /*TODO 自定义比较成员变量*/
                return ...;
            }
        ```
